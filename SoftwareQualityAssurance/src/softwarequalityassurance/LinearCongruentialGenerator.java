/*
 * @(#)LinearCongruentialGenerator.java		1.0 20/04/21
 * 
 * Copyright (c) 2020 University of Miskolc
 */

package softwarequalityassurance;

import java.util.LinkedList;
import java.util.List;

/**
 * This class provides the functionality of the program. It implements
 * the Linear Congruential Generator and its related functions.
 * 
 * @version 1.0 22 April 2020
 * @author Mario Posta, University of Miskolc, 2020.04.21.
 */
public class LinearCongruentialGenerator {
	
	/**
	 * The constant parameters of the generator.
	 */
	private int a, c;
	
	/**
	 * The module parameters of the generator.
	 */
	private int m, k;
	
	/**
	 * A list of integers which is a mathematical sequence generated
	 * by the algorithm.
	 */
	private List<Integer> sequence;
	
	/**
	 * Default constructor to create empty, uninitialized instance. 
	 */
	public LinearCongruentialGenerator() {
		super();
	}
	
	/**
	 * Returns the 'a' parameter.
	 * @return 'a' parameter of the generator
	 */
	public int getA() {
		return a;
	}
	
	/**
	 * Sets the 'a' parameter.
	 * @param a parameter of the generator
	 */
	public void setA(int a) {
		this.a = a;
	}
	
	/**
	 * Returns the 'c' parameter.
	 * @return 'c' parameter of the generator
	 */
	public int getC() {
		return c;
	}
	
	/**
	 * Sets the 'c' parameter.
	 * @param c parameter of the generator
	 */
	public void setC(int c) {
		this.c = c;
	}
	
	/**
	 * Returns the 'm' parameter.
	 * @return 'm' parameter of the generator
	 */
	public int getM() {
		return m;
	}
	
	/**
	 * Sets the 'm' parameter.
	 * @param m parameter of the generator
	 */
	public void setM(int m) {
		this.m = m;
	}
	
	/**
	 * Returns the 'k' parameter.
	 * @return 'k' parameter of the generator
	 */
	public int getK() {
		return k;
	}
	
	/**
	 * Sets the 'k' parameter.
	 * @param k parameter of the generator
	 */
	public void setK(int k) {
		this.k = k;
	}
	
	/**
	 * Returns a mathematical sequence generated by the algorithm.
	 * @return a mathematical sequence.
	 */
	public List<Integer> getSequence() {
		return sequence;
	}
	
	/**
	 * Sets the mathematical sequence generated by the algorithm.
	 * @param sequence a mathematical sequence
	 */
	public void setSequence(List<Integer> sequence) {
		this.sequence = sequence;
	}
	
	/**
	 * Initializes the parameters of the generator. Furthermore,
	 * it creates an empty list to store the sequence elements.
	 * @param a the 'a' parameter of the generator
	 * @param c the 'c' parameter of the generator
	 * @param m the 'm' parameter of the generator
	 * @param k the 'k' parameter of the generator
	 */
	public void setParameters(int a, int c, int m, int k)	{
		this.a = a;
		this.c = c;
		this.m = m;
		this.k = k;
		
		if (sequence == null)
			sequence = new LinkedList<Integer>();
		else
			sequence.clear();
	}
	
	/**
	 * Calculates an integer value that is the length of the longest repetition in
	 * a mathematical sequence provided by the Linear Congruential Generator (LCG).
	 * While the algorithm is generating the sequence, it is searching for equal
	 * elements that means a cycle. The algorithm generates two sequences (X, Y),
	 * where X the base sequence and Y derived from X. The Y is the main sequence,
	 * it stored in {@link LinearCongruentialGenerator#sequence}.
	 * @return the length of the longest repetition if it is exist, 0 otherwise
	 */
	int calculateCycleLength() {
		int currentXElement = 0, currentPosition = 0, 
			doubleSpeedCurrentPosition = 1, meetingPosition = -1, repeatingValue = -1;
		boolean cycle_is_exist = false;
		
		sequence.clear();
		sequence.add(0);

		for (int index = 0; index < m * 2; index++)
		{
			currentXElement = generateNextSequenceXElement(currentXElement);
			sequence.add(currentXElement);

			if (index % 2 == 0)
			{
				if (sequence.get(currentPosition) == sequence.get(doubleSpeedCurrentPosition))
				{
					repeatingValue = sequence.get(currentPosition);
					cycle_is_exist = true;
					meetingPosition = doubleSpeedCurrentPosition;
					break;
				}
				currentPosition++;
				doubleSpeedCurrentPosition += 2;
			}
		}

		if (cycle_is_exist)
		{
			return specifyDistanceBetweenRepeatingValues(meetingPosition, repeatingValue);
		}
		else
		{
			return 0;
		}
	}
	
	/**
	 * Generates the next element of the X sequence based on the latest X element.
	 * @param currentXElement the latest element of the X sequence
	 * @return the next element of the X sequence
	 */
	int generateNextSequenceXElement(int currentXElement)	{
		return (a * currentXElement + c) % m;
	}
	
	/**
	 * Specify the distance between equal values which means the length of the
	 * longest repetition in the mathematical sequence.
	 * @param meetingPosition the position of the index where the repeating value found
	 * @param repeatingValue the value that is repeating in the sequence
	 * @return integer value of the distance between equal values
	 */
	int specifyDistanceBetweenRepeatingValues(int meetingPosition, int repeatingValue)	{
		for (int index = meetingPosition - 1; index > -1; index--)
			if (sequence.get(index) == repeatingValue)
				return meetingPosition - index;
		return 0;
	}
	
}
