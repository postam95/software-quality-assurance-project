/*
 * @(#)LinearCongruentialGenerator.java		1.0 20/04/21
 * 
 * Copyright (c) 2020 University of Miskolc
 */

package hu.unimiskolc.softwarequalityassurance.lcg;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;

/**
 * This class provides the functionality of the program. It implements
 * the Linear Congruential Generator and its related functions.
 * 
 * @version 1.0 22 April 2020
 * @author Mario Posta, University of Miskolc, 2020.04.21.
 */
public class LinearCongruentialGenerator {
	
	/**
	 * The constant parameters of the generator.
	 */
	private long a, c;
	
	/**
	 * The module parameters of the generator.
	 */
	private long m, k;
	
	/**
	 * A list of integers which is a mathematical sequence generated
	 * by the algorithm.
	 */
	private List<Long> sequenceX;
	private List<Long> sequenceY;
	/**
	 * Default constructor to create empty, uninitialized instance. 
	 */
	public LinearCongruentialGenerator() {
		super();
	}
	
	/**
	 * Returns the 'a' parameter.
	 * @return 'a' parameter of the generator
	 */
	public long getA() {
		return a;
	}
	
	/**
	 * Sets the 'a' parameter.
	 * @param a parameter of the generator
	 */
	public void setA(long a) {
		this.a = a;
	}
	
	/**
	 * Returns the 'c' parameter.
	 * @return 'c' parameter of the generator
	 */
	public long getC() {
		return c;
	}
	
	/**
	 * Sets the 'c' parameter.
	 * @param c parameter of the generator
	 */
	public void setC(long c) {
		this.c = c;
	}
	
	/**
	 * Returns the 'm' parameter.
	 * @return 'm' parameter of the generator
	 */
	public long getM() {
		return m;
	}
	
	/**
	 * Sets the 'm' parameter.
	 * @param m parameter of the generator
	 */
	public void setM(long m) {
		this.m = m;
	}
	
	/**
	 * Returns the 'k' parameter.
	 * @return 'k' parameter of the generator
	 */
	public long getK() {
		return k;
	}
	
	/**
	 * Sets the 'k' parameter.
	 * @param k parameter of the generator
	 */
	public void setK(long k) {
		this.k = k;
	}
	
	/**
	 * Returns a mathematical sequence generated by the algorithm.
	 * @return a mathematical sequence.
	 */
	public List<Long> getSequenceX() {
		return sequenceX;
	}
	
	/**
	 * Sets the mathematical sequence generated by the algorithm.
	 * @param sequence a mathematical sequence
	 */
	public void setSequenceX(List<Long> sequence) {
		this.sequenceX = sequence;
	}
	
	/**
	 * Returns a mathematical sequence generated by the algorithm.
	 * @return a mathematical sequence.
	 */
	public List<Long> getSequenceY() {
		return sequenceY;
	}
	
	/**
	 * Sets the mathematical sequence generated by the algorithm.
	 * @param sequence a mathematical sequence
	 */
	public void setSequenceY(List<Long> sequence) {
		this.sequenceY = sequence;
	}
	
	/**
	 * Initializes the parameters of the generator. Furthermore,
	 * it creates an empty list to store the sequence elements.
	 * @param a the 'a' parameter of the generator
	 * @param c the 'c' parameter of the generator
	 * @param m the 'm' parameter of the generator
	 * @param k the 'k' parameter of the generator
	 */
	public void setParameters(long a, long c, long m, long k)	{
		this.a = a;
		this.c = c;
		this.m = m;
		this.k = k;

		if (sequenceX == null)
			sequenceX = new LinkedList<Long>();
		else
			sequenceX.clear();
		
		if (sequenceY == null)
			sequenceY = new LinkedList<Long>();
		else
			sequenceY.clear();
	}
	
	/**
	 * Calculates an integer value that is the length of the longest repetition in
	 * a mathematical sequence provided by the Linear Congruential Generator (LCG).
	 * While the algorithm is generating the sequence, it is searching for equal
	 * elements that means a cycle. The algorithm generates two sequences (X, Y),
	 * where X the base sequence and Y derived from X. The Y is the main sequence,
	 * it stored in {@link LinearCongruentialGenerator#sequenceX}.
	 * @return the length of the longest repetition if it is exist, 0 otherwise
	 */
	public long calculateCycleLength() {
		long currentXElement = 0, currentYElement = 0;
		long repeatingValue = -1;
		int currentPosition = 0, doubleSpeedCurrentPosition = 0, meetingPosition = -1;
		boolean cycle_is_exist = false;
		
		sequenceX.clear();
		sequenceX.add(0L);
		
		sequenceY.clear();
		sequenceY.add(0L);

		for (int index = 0; index < m * 3; index++)	{
			currentXElement = generateNextSequenceXElement(currentXElement);
			currentYElement = generateNextSequenceYElement(currentXElement);
			sequenceX.add(currentXElement);
			sequenceY.add(currentYElement);
			
			// Floyd's cycle finding algorithm to detect cycle in the sequence X.
			if (index % 2 == 0)	{
				if (index != 0 && (sequenceX.get(currentPosition).equals(sequenceX.get(doubleSpeedCurrentPosition))))	{
					repeatingValue = sequenceX.get(currentPosition);
					cycle_is_exist = true;
					meetingPosition = doubleSpeedCurrentPosition;
					break;
				}
				currentPosition++;
				doubleSpeedCurrentPosition += 2;
			}
		}

		if (cycle_is_exist)	{
			int lengthOfCycle = specifyDistanceBetweenRepeatingValues(meetingPosition, repeatingValue);
			return calculateInsiderCycle(meetingPosition - lengthOfCycle, lengthOfCycle);
		}
		else	{
			return 0;
		}
		
	}
	
	/**
	 * Calculates the length of the cycle in the sequence Y if it exists.
	 * Firstly it tries to find a possible cycle, afterwards it checks whether
	 * it is a real cycle.
	 * @param startPosition index of the beginning of the cycle in the sequence X
	 * @param lengthOfCycle length of the cycle occurs in the sequence X
	 * @return length of the insider cycle in the sequence Y if it exists, otherwise
	 * the length of the original cycle which is the second parameter
	 */
	int calculateInsiderCycle(int startPosition, int lengthOfCycle)	{
		Set<Long> supporterSet = new TreeSet<>();
		List<Long> insiderCycle = new ArrayList<>();
		int stopPosition = startPosition + lengthOfCycle - 1;
		
		for (int index = startPosition; index <= stopPosition; index++)	{
			if (!supporterSet.contains(sequenceY.get(index)))	{
				supporterSet.add(sequenceY.get(index));
				insiderCycle.add(sequenceY.get(index));
			}
			else
				break;
		}
		
		int size = insiderCycle.size();

		if (lengthOfCycle == size || lengthOfCycle % size != 0)
			return lengthOfCycle;
		
		for (int index = startPosition; index <= stopPosition; index++)	{
			if (sequenceY.get(index) != insiderCycle.get((index - startPosition) % size))
				return lengthOfCycle;
		}
		
		return size;
	}
	
	/**
	 * Generates the next element of the X sequence based on the latest X element.
	 * @param currentXElement the latest element of the X sequence
	 * @return the next element of the X sequence
	 */
	long generateNextSequenceXElement(long currentXElement)	{
		return (a * currentXElement + c) % m;
	}
	
	/**
	 * Generates the next element of the Y sequence based on the latest X element.
	 * @param currentXElement the latest element of the X sequence
	 * @return the next element of the Y sequence
	 */
	long generateNextSequenceYElement(long currentXElement)	{
		return currentXElement % k;
	}
	
	/**
	 * Specify the distance between equal values which means the length of the
	 * longest repetition in the mathematical sequence.
	 * @param meetingPosition the position of the index where the repeating value found
	 * @param repeatingValue the value that is repeating in the sequence
	 * @return integer value of the distance between equal values
	 */
	int specifyDistanceBetweenRepeatingValues(int meetingPosition, long repeatingValue)	{
		for (int index = meetingPosition - 1; index > -1; index--)	{			
			if (sequenceX.get(index).equals(repeatingValue))
				return meetingPosition - index;
		}

		return 0;
	}
	
	/**
	 * Reads parameters from console input and calls parameter setter method to initialize
	 * the Linear Congruential Generator.
	 * @param scanner
	 * @return number of values successfully read from console input
	 */
	public int readFromConsoleInput(Scanner scanner)	{
		int parameterCounter = 0;
		long a, c, m, k;
		
		a = scanner.nextLong();
		parameterCounter++;
		c = scanner.nextLong();
		parameterCounter++;
		m = scanner.nextLong();
		parameterCounter++;
		k = scanner.nextLong();
		parameterCounter++;
		
		setParameters(a, c, m, k);
		
		return parameterCounter;
	}
	
}
