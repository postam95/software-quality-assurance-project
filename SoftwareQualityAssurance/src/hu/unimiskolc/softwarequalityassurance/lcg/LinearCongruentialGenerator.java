/*
 * @(#)LinearCongruentialGenerator.java		1.0 20/04/21
 * 
 * Copyright (c) 2020 University of Miskolc
 */

package hu.unimiskolc.softwarequalityassurance.lcg;

import java.util.LinkedList;
import java.util.List;

/**
 * This class provides the functionality of the program. It implements
 * the Linear Congruential Generator and its related functions.
 * 
 * @version 1.0 22 April 2020
 * @author Mario Posta, University of Miskolc, 2020.04.21.
 */
public class LinearCongruentialGenerator {
	
	/**
	 * The constant parameters of the generator.
	 */
	private int a, c;
	
	/**
	 * The module parameters of the generator.
	 */
	private int m, k;
	
	/**
	 * A list of integers which is a mathematical sequence generated
	 * by the algorithm.
	 */
	private List<Integer> sequenceX;
	private List<Integer> sequenceY;
	/**
	 * Default constructor to create empty, uninitialized instance. 
	 */
	public LinearCongruentialGenerator() {
		super();
	}
	
	/**
	 * Returns the 'a' parameter.
	 * @return 'a' parameter of the generator
	 */
	public int getA() {
		return a;
	}
	
	/**
	 * Sets the 'a' parameter.
	 * @param a parameter of the generator
	 */
	public void setA(int a) {
		this.a = a;
	}
	
	/**
	 * Returns the 'c' parameter.
	 * @return 'c' parameter of the generator
	 */
	public int getC() {
		return c;
	}
	
	/**
	 * Sets the 'c' parameter.
	 * @param c parameter of the generator
	 */
	public void setC(int c) {
		this.c = c;
	}
	
	/**
	 * Returns the 'm' parameter.
	 * @return 'm' parameter of the generator
	 */
	public int getM() {
		return m;
	}
	
	/**
	 * Sets the 'm' parameter.
	 * @param m parameter of the generator
	 */
	public void setM(int m) {
		this.m = m;
	}
	
	/**
	 * Returns the 'k' parameter.
	 * @return 'k' parameter of the generator
	 */
	public int getK() {
		return k;
	}
	
	/**
	 * Sets the 'k' parameter.
	 * @param k parameter of the generator
	 */
	public void setK(int k) {
		this.k = k;
	}
	
	/**
	 * Returns a mathematical sequence generated by the algorithm.
	 * @return a mathematical sequence.
	 */
	public List<Integer> getSequence() {
		return sequenceX;
	}
	
	public List<Integer> getSequenceB() {
		return sequenceY;
	}
	
	/**
	 * Sets the mathematical sequence generated by the algorithm.
	 * @param sequence a mathematical sequence
	 */
	public void setSequence(List<Integer> sequence) {
		this.sequenceX = sequence;
	}
	
	/**
	 * Initializes the parameters of the generator. Furthermore,
	 * it creates an empty list to store the sequence elements.
	 * @param a the 'a' parameter of the generator
	 * @param c the 'c' parameter of the generator
	 * @param m the 'm' parameter of the generator
	 * @param k the 'k' parameter of the generator
	 */
	public void setParameters(int a, int c, int m, int k)	{
		this.a = a;
		this.c = c;
		this.m = m;
		this.k = k;

		sequenceY = new LinkedList<>();
		if (sequenceX == null)
			sequenceX = new LinkedList<Integer>();
		else
			sequenceX.clear();
	}
	
	/**
	 * Calculates an integer value that is the length of the longest repetition in
	 * a mathematical sequence provided by the Linear Congruential Generator (LCG).
	 * While the algorithm is generating the sequence, it is searching for equal
	 * elements that means a cycle. The algorithm generates two sequences (X, Y),
	 * where X the base sequence and Y derived from X. The Y is the main sequence,
	 * it stored in {@link LinearCongruentialGenerator#sequenceX}.
	 * @return the length of the longest repetition if it is exist, 0 otherwise
	 */
	public int calculateCycleLength() {
		int currentXElement = 0, currentYElement = 0, currentPosition = 0,
			doubleSpeedCurrentPosition = 0, meetingPosition = -1, repeatingValue = -1;
		boolean cycle_is_exist = false;
		
		sequenceX.clear();
		sequenceX.add(0);
		
		sequenceY.clear();
		sequenceY.add(0);

		for (int index = 0; index < m * 3; index++)	{
			currentXElement = generateNextSequenceXElement(currentXElement);
			currentYElement = generateNextSequenceYElement(currentXElement);
			sequenceX.add(currentXElement);
			sequenceY.add(currentYElement);

			if (index % 2 == 0)	{
				if (index != 0 && (sequenceX.get(currentPosition).equals(sequenceX.get(doubleSpeedCurrentPosition))))	{
					repeatingValue = sequenceX.get(currentPosition);
					cycle_is_exist = true;
					meetingPosition = doubleSpeedCurrentPosition;
					break;
				}
				currentPosition++;
				doubleSpeedCurrentPosition += 2;
			}
		}

		if (cycle_is_exist)	{
			int lengthOfCycle = specifyDistanceBetweenRepeatingValues(meetingPosition, repeatingValue);
			if (m > k && m % k == 0)	{
				lengthOfCycle = calculateInsiderCycleLength(meetingPosition, repeatingValue, lengthOfCycle);
			}
			return lengthOfCycle;
		}
		else	{
			return 0;
		}
		
	}
	
	int calculateInsiderCycleLength(int meetingPosition, int repeatingValue, int lengthOfCycle)	{
		int possibleLenghtOfInsiderCycle = lengthOfCycle / (m / k);
		boolean isInsiderCycleExist = true;

		for (int index = meetingPosition - 1; index >= meetingPosition - possibleLenghtOfInsiderCycle; index--)	{

			if (sequenceY.get(index) != sequenceY.get(index - possibleLenghtOfInsiderCycle))	{
				isInsiderCycleExist = false;
			}
		}

		return isInsiderCycleExist ? possibleLenghtOfInsiderCycle : lengthOfCycle;
	}
	
	/**
	 * Generates the next element of the X sequence based on the latest X element.
	 * @param currentXElement the latest element of the X sequence
	 * @return the next element of the X sequence
	 */
	int generateNextSequenceXElement(int currentXElement)	{
		return (a * currentXElement + c) % m;
	}
	
	/**
	 * Generates the next element of the Y sequence based on the latest X element.
	 * @param currentXElement the latest element of the X sequence
	 * @return the next element of the Y sequence
	 */
	int generateNextSequenceYElement(int currentXElement)	{
		return currentXElement % k;
	}
	
	/**
	 * Specify the distance between equal values which means the length of the
	 * longest repetition in the mathematical sequence.
	 * @param meetingPosition the position of the index where the repeating value found
	 * @param repeatingValue the value that is repeating in the sequence
	 * @return integer value of the distance between equal values
	 */
	int specifyDistanceBetweenRepeatingValues(int meetingPosition, int repeatingValue)	{
		for (int index = meetingPosition - 1; index > -1; index--)
			if (sequenceX.get(index) == repeatingValue)
				return meetingPosition - index;
		return 0;
	}
	
}
